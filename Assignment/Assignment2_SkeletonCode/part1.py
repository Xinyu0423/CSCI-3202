import GAinspector
import numpy as np
#import matplotlib.pyplot as plt
from utils import *


def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    """Your Code Here"""
    gene=""
    for i in range(length):
        temp=random.randint(0,1)
        gene=gene+str(temp)
    return gene



def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    """Your Code Here"""
    geneList=[]
    for i in range(size):
        gene=""
        for j in range(length):
            temp = random.randint(0, 1)
            gene = gene + str(temp)
        geneList.append(str(gene))
    return geneList


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    count=0
    for i in genome:
        if i=="1":
            count=count+1
    return count

def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    tempList=[]
    for i in population:
        tempList.append(fitness(i))
    average=sum(tempList)/len(tempList)
    return average,max(tempList)


def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    cutPoint=random.randint(1,len(genome1)-1)
    #print("--------------------------")
    #print("cut point is:",cutPoint)
    newGene1=""
    newGene2=""
    #print("length of genome1:",len(genome1))
    for i in range(0,len(genome1)):
        if i>=cutPoint:
            newGene1=newGene1+genome2[i]
            newGene2=newGene2+genome1[i]
        else:
            newGene1=newGene1+genome1[i]
            newGene2=newGene2+genome2[i]
    #print("after crossover, gene1:",newGene1)
    #print("after crossover, gene2:",newGene2)
    return newGene1,newGene2

def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    newGenome=""
    for i in range(0,len(genome)):
        tempRand=random.random()
        if mutationRate>tempRand:
            if genome[i]=="0":
                newGenome=newGenome+"1"
            elif genome[i]=="1":
                newGenome=newGenome+"0"
        else:
            newGenome=newGenome+genome[i]
    return newGenome


def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection. This function should use weightedChoice, which we wrote in class, as a helper function.
    """
    fitnessList=[]
    for i in population:
        fitnessList.append(fitness(i))
    newGene1=weightedChoice(population,fitnessList)
    newGene2=weightedChoice(population,fitnessList)
    return newGene1,newGene2



def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    print("Population size:",populationSize)
    print("Genome length: 20")
    population=makePopulation(populationSize,20)
    outputFile=open(logFile,"w")
    countWrite=0
    for i in range(0,50):
        mutatedList=[]
        newList=[]
        countPopulation = 0
        while (len(newList) != populationSize):
            selectedGene1, selectedGene2 = selectPair(population)
            crossoverRand = random.random()
            if crossoverRate > crossoverRand:
                selectedGene1, selectedGene2 = crossover(selectedGene1, selectedGene2)
            newList.append(selectedGene1)
            newList.append(selectedGene2)
        while(len(mutatedList)!=populationSize):
            tempMutate=mutate(newList[countPopulation],mutationRate)
            mutatedList.append(tempMutate)
            countPopulation=countPopulation+1

        population=mutatedList
        avg,best=evaluateFitness(mutatedList)

        if best==20:
            print("Generation", i, ": average fitness", avg, ", best fitness:", best)
            outputFile.write(str(i) + " " + str(avg) + " " + str(best) + "\n")
            print("Results saved in file", logFile)
            print(countWrite)
            return i
        print("Generation",i,": average fitness",avg,", best fitness:",best)
        outputFile.write(str(i)+" "+str(avg)+" "+str(best)+"\n")

        countWrite=countWrite+1
    outputFile.close()
    print("Results saved in file",logFile)
    print(countWrite)
    return -1


if __name__ == '__main__':
    #Testing Code
    print("Test Suite")
    GAinspector.test(randomGenome)
    GAinspector.test(makePopulation)
    GAinspector.test(fitness)
    GAinspector.test(evaluateFitness)
    GAinspector.test(crossover)
    GAinspector.test(mutate)
    #GAinspector.test(selectPair)


    #-------------------------------report 1----------------------------------
    best_i = []
    for j in (range(50)):
        #best_i.append(runGA(100, 0.7, 0.001, "run1.txt"))
        best_i.append(runGA(100, 0.7,0.001, str(j)+".txt"))
    print(best_i)
    minGeneration = min(i for i in best_i if i > 0)
    #minGeneCross = min(best_i)
    maxGeneration=max(best_i)
    sumGeneration=0
    countGeneration=0
    for i in best_i:
        if i!=-1:
            sumGeneration=sumGeneration+i
            countGeneration=countGeneration+1
    avgGeneration=round(sumGeneration/countGeneration,2)
    print("The average generation at which the string of all ones is discovered is",avgGeneration)
    print("The min generation at which the string of all ones is discovered is",minGeneration)
    print("The max generation at which the string of all ones is discovered is",maxGeneration)

    #---------------------------------report2--------------------------------------
    '''run1 = []
    run2 = []
    run3 = []
    run4 = []
    run5 = []
    listChoose = np.random.choice(range(50), 5, replace=False)
    #print("list choose:",listChoose[0])
    inputFile1 = open(str(listChoose[0]) + ".txt",'r')
    inputFile2 = open(str(listChoose[1]) + ".txt", 'r')
    inputFile3 = open(str(listChoose[2]) + ".txt", 'r')
    inputFile4 = open(str(listChoose[3]) + ".txt", 'r')
    inputFile5 = open(str(listChoose[4]) + ".txt", 'r')
    for line in inputFile1:
        fields=line.split(" ")
        run1.append(float(fields[1]))
    for line in inputFile2:
        fields=line.split(" ")
        run2.append(float(fields[1]))
    for line in inputFile3:
        fields=line.split(" ")
        run3.append(float(fields[1]))
    for line in inputFile4:
        fields=line.split(" ")
        run4.append(float(fields[1]))
    for line in inputFile5:
        fields=line.split(" ")
        run5.append(float(fields[1]))
    inputFile1.close()
    inputFile2.close()
    inputFile3.close()
    inputFile4.close()
    inputFile5.close()

    plt.plot(run1,color='skyblue',label="-run" + str(listChoose[0]))
    plt.plot(run2, color='yellow', label="-run" + str(listChoose[1]))
    plt.plot(run3, color='red', label="-run" + str(listChoose[2]))
    plt.plot(run4, color='green', label="-run" + str(listChoose[3]))
    plt.plot(run5, color='grey', label="-run" + str(listChoose[4]))
    plt.xlabel("Generation")
    plt.ylabel("Population average fitness")
    #plt.xticks([])
    plt.yticks([])
    #plt.legend(loc='best')
    plt.show()'''


    ''''#---------------------------------report3 and Report4--------------------------------
    #Because report3 and report 4 is changing the the parameter pass into the runGA function
    best_iCross = []
    for j in (range(50)):
        best_iCross.append(runGA(100, 0.0, 0.001, str(j)+"Cross" + ".txt"))
    print(best_iCross)
    #minGeneCross = min(i for i in best_iCross if i > 0)
    minGeneCross = min(best_iCross)
    maxGeneCross = max(best_iCross)
    #sumGeneCross = 0
    #countGeneCross = 0
    #for i in best_iCross:
    #    if i != -1:
    #        sumGeneCross = sumGeneCross + i
    #        countGeneCross = countGeneCross + 1
    #avgGeneCross = round(sumGeneCross / countGeneCross, 2)
    #print("The average generation when crossover rate is 0 is", avgGeneCross)
    print("The min generation when crossover rate is 0 is", minGeneCross)
    print("The max generation when crossover rate is 0 is", maxGeneCross)'''



    #print(runGA(100, 0.7, 0.001, "run1.txt"))
    #print(makePopulation(100,20))